# frozen_string_literal: true
require_relative '../../lib/cms_validators'
require_relative '../../lib/encounter_validator'

module UploadsHelper
  def node_type(type)
    NODE_TYPES[type]
  end

  def validator_name(validator)
    VALIDATOR_CATEGORIES[validator.to_sym]
  end

  def validator_slug(validator)
    validator.underscore.tr('/', '_')
  end

  def get_result_value(results, measure, population)
    result_value = results.where('value.measure_id' => measure.hqmf_id).where('value.sub_id' => measure.sub_id)
    result_value.first.value[population].to_i if result_value.first
  end

  def match_errors(upload)
    doc = upload.content
    uuid = UUID.new
    error_map = {}
    error_attributes = []
    locs = upload.errors.collect { |e| e['location'] }
    locs.compact!

    locs.each do |location|
      # Get rid of some funky stuff generated by schematron
      clean_location = location.gsub("[namespace-uri()='urn:hl7-org:v3']", '')
      node = doc.at_xpath(clean_location)
      next unless node
      elem = node
      if node.class == Nokogiri::XML::Attr
        error_attributes << node
        elem = node.element
      end
      elem = elem.root if node_type(elem.type) == :document
      next unless elem
      error_map[location] = elem['error_id'] ? elem['error_id'] : uuid.generate.to_s
    end

    [error_map, error_attributes]
  end

  def should_switch_highlight?(data_key, pop_key, specifics, rationale)
    # determine if final specifics indicates a "specifically false" switch

    # data criteria specifics arrays
    dc_specifics = rationale[data_key][:specifics]

    if specifics && specifics[pop_key] && !specifics[pop_key].empty?
      # iterate over all final specifics arrays in this population
      specifics[pop_key].each do |final_spec_arr|
        # compare to all specifics arrays for this data criteria
        dc_specifics.each do |data_crit_spec_arr|
          # if any spec comparison matches, don't switch highlight
          return false if spec_arrays_match?(final_spec_arr, data_crit_spec_arr)
        end
      end
      # if none match, switch highlight
      return true
    end

    # if there are no population specifics, check for all wildcard in any dc_arr (implicit match)
    dc_specifics.each do |data_crit_spec_arr|
      # if any spec comparison matches, don't switch highlight
      return false if found_implicit_match?(data_crit_spec_arr)
    end
    # switch highlight if none match
    true
  end

  def spec_arrays_match?(fs_arr, dc_arr)
    # if each element is the same as the corresponding element (or either is
    # a wildcard) then true (spec matches)
    fs_arr.each_with_index do |fs, i|
      if i < dc_arr.length && fs != '*' && dc_arr[i] != '*' && fs != dc_arr[i]
        return false
      end
    end
    true
  end

  def found_implicit_match?(dc_arr)
    dc_arr.each do |dc_spec_item|
      return false unless dc_spec_item == '*'
    end
    true
  end

  def first_nested_criteria(criteria)
    # search criteria hierarchy for the "first" concrete criteria
    # that is not some other hierarchical grouping
    root_criteria = criteria
    while root_criteria[:children_criteria] &&
          (!root_criteria[:definition].include? 'satisfies')
      root_criteria = dc_access[root_criteria[:children_criteria][0]]
    end
    root_criteria
  end

    def specifics_rationale(measure, rationale, final_specifics)
      # byebug
      updated_rationale = {}
      or_counts = calculate_or_counts(measure, rationale)
      data_crit_hash = measure[:hqmf_document][:data_criteria]
      keyed_data_crit_hash = create_keyed_hash(data_crit_hash)

      measure[:population_ids].values.uniq.each do |id|
        pop_map = measure.hqmf_document[:population_criteria].select{|k, h| h[:hqmf_id] == id }
        population = pop_map.values[0]
        code = population[:type]
        specifics = final_specifics[code]
        if specifics
          updated_rationale[code] = {}
          # get the referenced occurrences in the logic tree using original population code
          criteria = get_data_criteria_keys(population, data_crit_hash, code).uniq
          criteria_results = check_criteria_for_rationale(final_specifics, criteria, rationale, data_crit_hash, code)
          submeasure_code = pop_map.keys[0]# @population.get(code)?.code || code ???

          # parent_map = build_parent_map(@measure.get('population_criteria')[submeasure_code])
          parent_map = build_parent_map(population, keyed_data_crit_hash)

          # check each bad occurrence and remove highlights marking true
          criteria_results[:bad].each do |bad_criteria|
            if(rationale[bad_criteria])
              updated_rationale[code][bad_criteria] = false
              # move up the logic tree to set AND/ORs to false based on the removal of the bad specific's true eval
              updated_rationale = update_logic_tree(updated_rationale, rationale, code, bad_criteria, or_counts, parent_map, final_specifics)
            end
          end
          # check the good specifics with a negated parent.  If there are multiple candidate specifics
          # and one is good while the other is bad, the child of the negation will evaluate to true, we want it to
          # evaluate to false since if there's a good negation then there's an occurrence for which it evaluated to false
          criteria_results[:good].each do |good_criteria|
            updated_rationale[code] = updated_negated_good(updated_rationale[code], rationale, good_criteria, parent_map)
          end

        end
      end
      # byebug
      return updated_rationale
    end

    def create_keyed_hash(input_hash)
      output = {}
      input_hash.each do |key,val|
        output[key]=val
        output[key][:key]=key
      end
      return output
    end


    def get_data_criteria_keys(child, data_crit_hash, key=nil)
      # byebug
      occurrences = []
      return occurrences unless child
      if child[:preconditions] && child[:preconditions].length > 0
        child[:preconditions].each do |precondition|
          occurrences = occurrences.concat get_data_criteria_keys(precondition, data_crit_hash)
        end
      elsif child[:reference]
        occurrences = occurrences.concat get_data_criteria_keys(data_crit_hash[child[:reference]], data_crit_hash, child[:reference])
      else
        if child[:type]=='derived' && child[:children_criteria]
          # add derived to DC list if it's a satisfies all/any or a variable
          occurrences.push key if key && (child[:definition]=='satisfies_all' || child[:definition]=='satisfies_any' || child[:variable])
          child[:children_criteria].each do |data_criteria_key|
            data_criteria = data_crit_hash[data_criteria_key]
            occurrences = occurrences.concat get_data_criteria_keys(data_criteria, data_crit_hash, data_criteria_key)
          end
        else
          occurrences.push key if key
        end
        if (child[:temporal_references] && child[:temporal_references].length > 0)
          child[:temporal_references].each do |temporal_reference|
            data_criteria = data_crit_hash[temporal_reference[:reference]]
            occurrences = occurrences.concat get_data_criteria_keys(data_criteria, data_crit_hash, temporal_reference[:reference])
          end
        end

        if (child[:references] && child[:references].length>0)
          # for type, reference of child.references ???
          child[:references].each do |reference|
            data_criteria = data_crit_hash[reference[:reference]]
            occurrences = occurrences.concat get_data_criteria_keys(data_criteria, data_crit_hash, reference[:reference])
          end
        end
      end
      return occurrences
    end


    def check_criteria_for_rationale(final_specifics, criteria, rationale, data_crit_hash, pop_key)
      # byebug
      results = {bad: [], good: []}
      criteria.each do |criterion|
        criterion_rationale = rationale[criterion]

        # handle the case where the rationale does not contain a criteria
        if (criterion_rationale==nil)
          puts 'WARNING: data criteria '+criterion+' is not contained in the rationale'
          next
        end

        if (criterion_rationale &&
          criterion_rationale.is_a?(Hash) &&
          criterion_rationale[:specifics] &&
          criterion_rationale[:specifics].length > 0 &&
          should_switch_highlight?(criterion, pop_key, final_specifics, rationale))

          results[:bad].push(criterion)
        else
          results[:good].push(criterion)
        end
      end
      return results
    end

    # Or counts are used to know when to turn an OR from green to red.  Once we negate all the true ors, we can switch to red
    def calculate_or_counts (measure, rationale)
      # byebug
      or_counts = {}
      measure[:population_ids].values.uniq.each do |id|
        # byebug
        pop_map = measure.hqmf_document[:population_criteria].select{|k, h| h[:hqmf_id] == id }
        population = pop_map.values[0]

        or_counts = or_counts.merge(calculate_or_counts_recursive(rationale, population[:preconditions]))
      end
      or_counts.merge(calculate_data_criteria_or_counts(measure, rationale))
    end

    # recursively walk preconditions to count true values for child ORs moving down the tree
    def calculate_or_counts_recursive (rationale, preconditions)
      or_counts = {}
      return or_counts unless preconditions && preconditions.length > 0
      preconditions.each do |precondition|
        if (precondition[:conjunction_code] == 'atLeastOneTrue' && !precondition[:negation])
          trueCount = 0
          if precondition[:preconditions] && precondition[:preconditions].length > 0
            precondition[:preconditions].each do |child|
              if (child[:preconditions])
                key = "precondition_#{child[:id]}"
              else
                key = child[:reference]
              end
              trueCount += 1 if rationale[key]
            end
          end
          or_counts["precondition_#{precondition[:id]}"] = trueCount
        end
        or_counts = or_counts.merge calculate_or_counts_recursive(rationale, precondition[:preconditions])
      end
      return or_counts
    end

    # walk through data criteria to account for specific occurrences within a UNION
    def calculate_data_criteria_or_counts(measure, rationale)
      or_counts = {}
      measure[:hqmf_document][:data_criteria].each do |key,dc|
        if dc[:derivation_operator] == 'UNION' && (key.include?('UNION') || key.include?('satisfiesAny'))
          dc[:children_criteria].each do |child|
            or_counts[key] = (or_counts[key] || 0) + 1 if rationale[child] # Only add to orCount for logically true branches
          end
        end
      end
      or_counts
    end

    def updated_negated_good(updated_rationale, rationale, good_occurrence, parent_map)
      parent = parent_map[good_occurrence]
      while parent do
        # byebug
        # TODO: get rid of array in hash?
        if (parent[0][:negation] && rationale[good_occurrence])
          updated_rationale[good_occurrence] = false
          return
        end
        parent = parent_map["precondition_#{parent[0][:id]}"]
      end
      return updated_rationale
    end

    def build_parent_map(root, data_crit_hash)
      parent_map = {}
      return parent_map unless root
      if root[:preconditions] && root[:preconditions].length > 0
        root[:preconditions].each do |precondition|
          parent_map["precondition_#{precondition[:id]}"] = (parent_map["precondition_#{precondition[:id]}"] || []).push root
          parent_map = parent_map.merge(build_parent_map(precondition, data_crit_hash)){|key, oldval, newval| oldval.concat newval}
        end
      elsif root[:reference]
        parent_map[root[:reference]] = (parent_map[root[:reference]] || []).push root
        parent_map = parent_map.merge(build_parent_map(data_crit_hash[root[:reference]], data_crit_hash)){|key, oldval, newval| oldval.concat newval}
      else
        if root[:temporal_references]
          root[:temporal_references].each do |temporal_reference|
            if temporal_reference[:reference] != 'MeasurePeriod'
              parent_map[temporal_reference[:reference]] = (parent_map[temporal_reference[:reference]] || []).push root
              parent_map = parent_map.merge(build_parent_map(data_crit_hash[temporal_reference[:reference]], data_crit_hash)){|key, oldval, newval| oldval.concat newval}
            end
          end
        end
        if root[:references] # ??? check for :references in db
          root[:references].each do |reference|
            parent_map[reference[:reference]] = (parent_map[reference[:reference]] || []).push root
            parent_map = parent_map.merge(build_parent_map(data_crit_hash[reference[:reference]], data_crit_hash)){|key, oldval, newval| oldval.concat newval}
          end
        end
        if root[:children_criteria]
          root[:children_criteria].each do |child|
            parent_map[child] = (parent_map[child] || []).push root
            parent_map = parent_map.merge(build_parent_map(data_crit_hash[child], data_crit_hash)){|key, oldval, newval| oldval.concat newval}
          end
        end
      end
      parent_map
    end

    # from each leaf walk up the tree updating the logical statements appropriately to false
    def update_logic_tree(updated_rationale, rationale, code, bad_occurrence, or_counts, parent_map, final_specifics)
      parents = parent_map[bad_occurrence]
      return update_logic_tree_children(updated_rationale, rationale, code, parents, or_counts, parent_map, final_specifics)
    end

    def update_logic_tree_children(updated_rationale, rationale, code, parents, or_counts, parent_map, final_specifics)
      return updated_rationale unless parents
      parents.each do |parent|
        # TODO: fix 'key'
        parent_key = parent[:id]? "precondition_#{parent[:id]}" : parent[:key] || parent[:type]
        # we are negated if the parent is negated and the parent is a precondition.  If it's a data criteria, then negation is fine
        negated = parent[:negation] && parent[:id]
        # do not bubble up negated unless we have no final specifics.  If we have no final specifics then we may not have positive statements to bubble up.
        if updated_rationale[code][parent_key] != false && (!negated || final_specifics[code].empty?)
          # if this is an OR then remove a true increment since it's a bad true
          or_counts[parent_key]= or_counts[parent_key]-1 if or_counts[parent_key]
          # if we're either an AND or we're an OR and the count is zero then switch to false and move up the tree
          if ((!or_counts[parent_key] || or_counts[parent_key] == 0) && (!!rationale[parent_key] == true || !rationale.key?(parent_key))) # ??? undefinied???
            updated_rationale[code][parent_key] = false if rationale[parent_key]
            updated_rationale = update_logic_tree_children(updated_rationale, rationale, code, parent_map[parent_key], or_counts, parent_map, final_specifics)
          end
        end
      end
      return updated_rationale
    end

    def final_rationale_ref(reference)
      return nil if(@population_key == "OBSERV")
      rat_ref = nil
      if (@specifics[@population_key] || @population_key == 'VAR')
        rat_ref = @rationale[reference]
        rat_ref = rat_ref[:results].count > 0 if rat_ref.is_a?(Hash)
        if @population_key != 'VAR' &&
              @updated_rationale[@population_key] &&
              @updated_rationale[@population_key].key?(reference)
          rat_ref = @updated_rationale[@population_key][reference]
        end
      end
      return rat_ref
    end

    def should_star?(reference)
      return(@specifics[@population_key] &&
            @population_key != 'VAR' &&
            @updated_rationale[@population_key] &&
            @updated_rationale[@population_key].key?(reference))
    end

end
