require_relative "../../lib/cms_validators"
require_relative "../../lib/encounter_validator"

module UploadsHelper

    def node_type(type)
      return NODE_TYPES[type]
    end

    def validator_name(validator)
      VALIDATOR_CATEGORIES[validator.to_sym]
    end

    def validator_slug(validator)
      validator.underscore.gsub("/", "_")
    end

    def get_result_value(results, measure, population)
      result_value = results.where('value.measure_id' => measure.hqmf_id).where('value.sub_id' => measure.sub_id)
      result_value.first.value[population].to_i if result_value.first
    end

    def match_errors(upload)
      doc = upload.content
      uuid = UUID.new
      error_map = {}
      error_id = 0
      error_attributes = []
      locs = upload.errors.collect{|e| e['location']}
      locs.compact!

      locs.each do |location|
        # Get rid of some funky stuff generated by schematron
        clean_location = location.gsub("[namespace-uri()='urn:hl7-org:v3']", '')
        node = doc.at_xpath(clean_location)
        if(node)
          elem = node
          if node.class == Nokogiri::XML::Attr
            error_attributes << node
            elem = node.element
          end
          elem = elem.root if node_type(elem.type) == :document
          if elem

            unless elem['error_id']

              elem['error_id']= uuid.generate.to_s
            end
            error_map[location] = elem['error_id']
          end
        end
      end

      return error_map, error_attributes
    end

    def should_switch_highlight?(data_key, pop_key, specifics, rationale)
      # check final specifics approach
      if specifics && specifics[pop_key]
        pop_final_specifics = []
        unless specifics[pop_key].empty?
          # first specfics entry for this population is final specifics array
          pop_final_specifics = specifics[pop_key][0]
        end
        return has_specifics?(data_key, rationale, pop_final_specifics)
      end
      false
    end

    def has_specifics?(data_key, rationale, pop_final_specifics)
      if rationale[data_key][:specifics] &&
         !rationale[data_key][:specifics].empty?
        # get this data criteria's specific info
        dc_specifics = rationale[data_key][:specifics][0]
        dc_specifics.each do |dc_spec|
          # find any data criteria specific entry that is not included
          # in the population final specifics
          return true if (dc_spec != '*') && !pop_final_specifics.include?(dc_spec)
        end
      end
      false
    end

    def first_nested_criteria(criteria)
      # search criteria hierarchy for the "first" concrete criteria
      # that is not some other hierarchical grouping
      root_criteria = criteria
      while root_criteria[:children_criteria] &&
            (!root_criteria[:definition].include? 'satisfies')
        root_criteria = dc_access[root_criteria[:children_criteria][0]]
      end
      root_criteria
    end

end
