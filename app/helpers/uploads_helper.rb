require_relative '../../lib/cms_validators'
require_relative '../../lib/encounter_validator'

module UploadsHelper
  def node_type(type)
    NODE_TYPES[type]
  end

  def validator_name(validator)
    VALIDATOR_CATEGORIES[validator.to_sym]
  end

  def validator_slug(validator)
    validator.underscore.gsub("/", "_")
  end

  def get_result_value(results, measure, population)
    result_value = results.where('value.measure_id' => measure.hqmf_id).where('value.sub_id' => measure.sub_id)
    result_value.first.value[population].to_i if result_value.first
  end

  def match_errors(upload)
    doc = upload.content
    uuid = UUID.new
    error_map = {}
    error_attributes = []
    locs = upload.errors.collect { |e| e['location'] }
    locs.compact!

    locs.each do |location|
      # Get rid of some funky stuff generated by schematron
      clean_location = location.gsub("[namespace-uri()='urn:hl7-org:v3']", '')
      node = doc.at_xpath(clean_location)
      next unless node
      elem = node
      if node.class == Nokogiri::XML::Attr
        error_attributes << node
        elem = node.element
      end
      elem = elem.root if node_type(elem.type) == :document
      next unless elem
      error_map[location] = elem['error_id'] ? elem['error_id'] : uuid.generate.to_s
    end

    return error_map, error_attributes
  end

  def should_switch_highlight?(data_key, pop_key, specifics, rationale)
    # determine if final specifics indicates a "specifically false" switch

    # data criteria specifics arrays
    dc_specifics = rationale[data_key][:specifics]

    if specifics && specifics[pop_key] && !specifics[pop_key].empty?
      # iterate over all final specifics arrays in this population
      specifics[pop_key].each do |final_spec_arr|
        # compare to all specifics arrays for this data criteria
        dc_specifics.each do |data_crit_spec_arr|
          # if any spec comparison matches, don't switch highlight
          return false if spec_arrays_match?(final_spec_arr, data_crit_spec_arr)
        end
      end
      # if none match, switch highlight
      return true
    end

    # if there are no population specifics, check for all wildcard in any dc_arr (implicit match)
    dc_specifics.each do |data_crit_spec_arr|
      # if any spec comparison matches, don't switch highlight
      return false if found_implicit_match?(data_crit_spec_arr)
    end
    # switch highlight if none match
    true
  end

  def spec_arrays_match?(fs_arr, dc_arr)
    # if each element is the same as the corresponding element (or either is
    # a wildcard) then true (spec matches)
    fs_arr.each_with_index do |fs, i|
      if i < dc_arr.length && fs != '*' && dc_arr[i] != '*' && fs != dc_arr[i]
        return false
      end
    end
    true
  end

  def found_implicit_match?(dc_arr)
    dc_arr.each do |dc_spec_item|
      return false unless dc_spec_item == '*'
    end
    true
  end

  def first_nested_criteria(criteria)
    # search criteria hierarchy for the "first" concrete criteria
    # that is not some other hierarchical grouping
    root_criteria = criteria
    while root_criteria[:children_criteria] &&
          (!root_criteria[:definition].include? 'satisfies')
      root_criteria = dc_access[root_criteria[:children_criteria][0]]
    end
    root_criteria
  end
end
